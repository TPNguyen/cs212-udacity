Notes for Desigh of Computer Programs course in Python from Udacity cs212


Define a Poker Program


A card has a rank and a suit eg. 3 of Diamonds or 3D
hand = 5 cards
hands is a list of hand eg. [hand1, hand2, ..]
poker(hands) -> hand # function poker returns the best hand


Hand rank concept:
n-kind 22  33  888
straight 56789
flush 	 5 diamonds or 5 hearts etc

Order of ranks from highest to lowest:
8 - Straight and Flush
7 - Four of a kind
6 - Full House (3 kinds and 2 kinds)
5 - Flush
4 - Straight
3 - Three of a kind
2 - Two 2 of a kinds
1 - Two of a kind
0 - Nothing

'--23456789TJQKA'.index(r) : Returns a number from 2 to 14 for any rank r.

<List>.count(<element>) : Returns the no. of times the element is present in the list.

To find no. of unique elements in a list, convert it to a set and then check its length : len(set(<List>))

To create a list from a part of another list, use something like: 
List1 = [a.some_function() for a,b in List2] 

Combine if statement with return:
return a if <condition> else b


List comprehensions:

udacity_tas = ['Peter', 'Andy', 'Sarah', 'Job', 'Sean', 'Parker']
uppercase_tas = [name.upper() for name in udacity_tas]

This is possible for all iterable objects: strings, lists, tuples


Multiple values can be unpacked and combined with if statement like below:

ta_data = [('Peter', 'Australia', 'CS101'),
	  ('Andy', 'Brazil', 'CS212'),
	  ('Sarah', 'England', 'CS375'),
	  ('Job', 'Germany', 'CS301'),
	  ('Sean', 'France', 'CS251'),
	  ('Parker', 'USA', 'CS153')]

ta_facts = [name + ' from ' + country + ' is the TA for ' + course for name, country, course in ta_data if course.find('CS3') != -1]


defaultdict :

Using list as the default_factory, it is easy to group a sequence of key-value pairs into a dictionary of lists:

>>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
>>> d = defaultdict(list)
>>> for k, v in s:
...     d[k].append(v)
...
>>> d.items()
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]


int as default_factory is useful for counting (like a bag or multiset in other languages):

>>> s = 'mississippi'
>>> d = defaultdict(int)
>>> for k in s:
...     d[k] += 1
... 
>>> d.items()	
[('i', 4), ('p', 2), ('s', 4), ('m', 1)]


Functions are of 'computing' type and 'doing' type. 
Computing fns: sine, sqrt  
	       Take input and return an output like mathematical fns.
	       Easier to use and test. Should be preffered.
	       sorted([3,2,1]) == [1,2,3]

'Doing' type: shuffle()
	      Modify the input. Takes more code - setup the state, call the subroutine or method, and inspect the state (assert statement)
	      input = [3,2,1]
	      input.sort()
	      input == [1,2,3]


itertools.combinations(iterable, r):
Returns r length subsequences of elements from the input iterable.

Can be used like:
return max(itertools.combinations(hand, 5), key=hand_rank)

Examples:
# combinations('ABCD', 2) --> AB AC AD BC BD CD
# combinations(range(4), 3) --> 012 013 023 123

---

itertools.product :

Cartesian product of input iterables.

E.g.:
>>> list(itertools.product('ABCD', 'xy'))
[('A', 'x'), ('A', 'y'), ('B', 'x'), ('B', 'y'), ('C', 'x'), ('C', 'y'), ('D', 'x'), ('D', 'y')]

Applies to any iterable:
>>> list(itertools.product(['A', 'B', 'C'], ['x'], ['z','w']))
[('A', 'x', 'z'), ('A', 'x', 'w'), ('B', 'x', 'z'), ('B', 'x', 'w'), ('C', 'x', 'z'), ('C', 'x', 'w')]

Use repeat to specify if additonal 
>>> list(itertools.product('ABC', repeat=2))
[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]

>>> list(itertools.product('01', repeat=3))
[('0', '0', '0'), ('0', '0', '1'), ('0', '1', '0'), ('0', '1', '1'), ('1', '0', '0'), ('1', '0', '1'), ('1', '1', '0'), ('1', '1', '1')]

---

map(function, iterable, ...)

Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. (Built in function)

---

Generator functions:

Similar to generator expression

def ints(start, end):
    i = start
    while i<= end:
    	  yield i
	  i = i + 1

To call the above fn:

L = ints(0, 100000)
L won't be a list right away. It will be a generator object.
L = <generator>
next(L) gives 0 as output.
Normally this function will be used with a for:
for i in L: ...	       

Generator functions allow us to deal with infinite sequences.

def ints(start, end=None):
    i = start
    while i <= end or end is None:
    	  yield i
	  i = i + 1

ints(0) generates infinite sequence 0, 1, 2...

# Define a function, all_ints(), that generates the 
# integers in the order 0, +1, -1, +2, -2, ...

def all_ints():
    "Generate integers in the order 0, +1, -1, +2, -2, +3, -3, ..."
    yield 0
    i = 1
    while True:
        yield +i
	yeild -i
	i += 1

---

for loops:

for loop internally creates an iterable object using iter(). 

for x in items:
    print x

when the above code is run, the following code is actually implemented:
     
it = iter(items):
try:
     while True:
     	   x = next(it)
	   print x
except StopIteration:
     pass

---

Use ''.join(a) to make a string from a tupple or list of strings or from another string.

If a tupple of ints is to converted to a single string use ''.join(map(str, <tupple>))

eg. ', '.join('AEIOU') => 'A, E, I, O, U' 

---

When a list is to be returned, check if returning a generator object makes sense: When you don't have to necessarily iterate over the whole list and you might get lucky after a few iterations, making a generator function is the correct thing.
Example: In module 2, fill_in() we said yield in a for loop instead of returning a list:

def fill_in(formula):
    "Generate all possible fillings-in of letters in formula with digits."
    letters = ''.join(set(re.findall('[A-Z]', formula)))
    for digits in itertools.permutations('1234567890', len(letters)):
        table = string.maketrans(letters, ''.join(digits))
        yield formula.translate(table)

This is because we might have gotten our valid formula before the complete iteration.

---

To find out time taken in a file by each function, no. of calls, time per call, etc., use the module cProfile:

From the terminal run:
python -m cProfile <file_to_test>.py 

OR

From inside the script, add the following to the code:

import cProfile
cProfile.run('test()') # where the timing data for test() is required.

---

Handling types "polymorphism"

To check type of a variable use isinstance():
if(isinstance(n, int)):
	...
else:
	...

---

Use brackets inside re.split() to include the chars of split.

str_to_split = 'YOU==ME**2'
list1 = re.split('([A-Z]+)', str_to_split) # ['YOU', '==', 'ME', '**2']
list2 = re.split('[A-Z]+'  , str_to_split) # ['==', '**2']

